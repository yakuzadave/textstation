'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _QuestStep = require('./QuestStep');

var _QuestStep2 = _interopRequireDefault(_QuestStep);

var _character = require('../character');

var _general = require('../general');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Quest = function () {
  function Quest(_ref) {
    var _this = this;

    var text = _ref.text,
        _ref$steps = _ref.steps,
        steps = _ref$steps === undefined ? [] : _ref$steps;

    _classCallCheck(this, Quest);

    this._text = text;
    this._steps = [];
    this._rewarded = false;
    steps.forEach(function (step) {
      return _this.addStep(step);
    });
  }

  _createClass(Quest, [{
    key: 'getText',
    value: function getText() {
      return this._text;
    }
  }, {
    key: 'getSteps',
    value: function getSteps() {
      return this._steps;
    }
  }, {
    key: 'addStep',
    value: function addStep(step) {
      if (!(step instanceof _QuestStep2.default)) {
        step = new _QuestStep2.default(step);
      }
      this._steps.push(step);
    }
  }, {
    key: 'getProgress',
    value: function getProgress() {
      return this._steps.filter(function (_step) {
        return _step.isCompleted();
      }).length / this._steps.length;
    }
  }, {
    key: 'isCompleted',
    value: function isCompleted() {
      return this.getProgress() === 1;
    }
  }, {
    key: 'isRewardClaimed',
    value: function isRewardClaimed() {
      return this._rewarded;
    }
  }, {
    key: 'interaction',
    value: function interaction(character) {
      return {
        join: this._joiner(character),
        drop: this._droper(character),
        completeStep: this._stepCompleter(character),
        claimReward: this._claimRewarder(character)
      };
    }
  }, {
    key: '_claimRewarder',
    value: function _claimRewarder(character) {
      var _this2 = this;

      return function () {
        return new Promise(function (resolve, reject) {
          if (!_this2.isCompleted()) return reject(new Error('Hero cannot claim quest reward because the quest isn\'t completed'));
          if (_this2.isRewardClaimed()) return reject(new Error('Quest reward already claimed'));
          var rewards = _this2._getRewards();
          rewards.reduce(function (iterator, reward) {
            return iterator.then(function () {
              if (reward instanceof _character.Experience) {
                return character.experience.gain(reward);
              } else if (reward instanceof _general.Currency) {
                return character.bank.earn(reward);
              } else if (reward instanceof _general.Item) {
                return character.inventory.carry(reward);
              }
            });
          }, Promise.resolve([])).then(function () {
            _this2._rewarded = true;
            resolve();
          });
        });
      };
    }
  }, {
    key: '_getRewards',
    value: function _getRewards() {
      return (this._steps || []).map(function (step) {
        return step.getReward();
      });
    }
  }, {
    key: '_validatePossession',
    value: function _validatePossession(character) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var quest = character.quests.findQuest(_this3);
        if (!quest) return reject(new Error('Hero haven\'t joined this quest'));
        resolve(true);
      });
    }
  }, {
    key: '_stepCompleter',
    value: function _stepCompleter(character) {
      var _this4 = this;

      return function (stepIndex) {
        return _this4._validatePossession(character).then(function () {
          return _this4.getSteps()[stepIndex].completeStep();
        });
      };
    }
  }, {
    key: '_droper',
    value: function _droper(character) {
      var _this5 = this;

      return function () {
        return new Promise(function (resolve, reject) {
          character.quests.removeQuest(_this5);
          resolve();
        });
      };
    }
  }, {
    key: '_joiner',
    value: function _joiner(character) {
      var _this6 = this;

      return function () {
        return new Promise(function (resolve, reject) {
          character.quests.addQuest(_this6);
          resolve();
        });
      };
    }
  }]);

  return Quest;
}();

exports.default = Quest;
module.exports = exports['default'];