'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ = require('../..');

var _helpers = require('../../../helpers');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Equipment = function () {
  function Equipment(_ref) {
    var _ref$items = _ref.items,
        items = _ref$items === undefined ? [] : _ref$items,
        _ref$slots = _ref.slots,
        slots = _ref$slots === undefined ? [] : _ref$slots;

    _classCallCheck(this, Equipment);

    this._items = this._parseItems(items);
    this._slots = this._parseSlots(slots);
  }

  _createClass(Equipment, [{
    key: 'getSlots',
    value: function getSlots() {
      return this._slots;
    }
  }, {
    key: 'getWeapons',
    value: function getWeapons() {
      return this._items.filter(function (item) {
        return item instanceof _.Weapon;
      });
    }
  }, {
    key: 'getModifiers',
    value: function getModifiers() {
      return this._items.filter(function (item) {
        return item.getEffects || item.getAttacks;
      }).reduce(function (modifiers, item) {
        if (item.getEffects) modifiers = modifiers.concat(item.getEffects());
        if (item.getAttacks) modifiers = modifiers.concat(item.getAttacks());
        return modifiers;
      }, []);
    }
  }, {
    key: 'equip',
    value: function equip(item) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (!_this._slots.length) return reject(new Error('No available slot'));
        for (var i = 0, l = _this._slots.length; i < l; i++) {
          var slot = _this._slots[i];
          if (slot.getType().getName() === item.getSlotType().getName()) {
            if (_this._countItemsFromSlot(slot) + 1 <= slot.getCapacity()) {
              _this._items.push(item);
              resolve(_this._items[_this._items.length - 1]);
            } else {
              reject(new Error('Exceeded slot capacity'));
            }
            break;
          }
        }
      });
    }
  }, {
    key: 'addSlot',
    value: function addSlot(_ref2) {
      var type = _ref2.type,
          _ref2$capacity = _ref2.capacity,
          capacity = _ref2$capacity === undefined ? 1 : _ref2$capacity;

      this._slots.push(new _.Slot({ type: type, capacity: capacity }));
    }
  }, {
    key: '_parseItems',
    value: function _parseItems(items) {
      return (0, _helpers.parseToInstance)(_.Item, items);
    }
  }, {
    key: '_parseSlots',
    value: function _parseSlots(slots) {
      return (0, _helpers.parseToInstance)(_.Slot, slots);
    }
  }, {
    key: '_countItemsFromSlot',
    value: function _countItemsFromSlot(slot) {
      return this._items.filter(function (item) {
        return item.getSlotType().getName() === slot.getType().getName();
      }).length;
    }
  }]);

  return Equipment;
}();

exports.default = Equipment;
module.exports = exports['default'];