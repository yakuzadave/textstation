'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require('../../../constants');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Battle = function () {
  function Battle(_ref) {
    var character = _ref.character;

    _classCallCheck(this, Battle);

    var constants = {
      events: {
        BATTLE_BEFORE_ATTACK: 'battle:[before]attack',
        BATTLE_AFTER_ATTACK: 'battle:[after]attack',
        BATTLE_BEFORE_DEFEND: 'battle:[before]defend',
        BATTLE_AFTER_DEFEND: 'battle:[after]defend',
        BATTLE_BEFORE_TAKING_DAMAGE: 'battle:[before]takingDamage',
        BATTLE_AFTER_TAKING_DAMAGE: 'battle:[after]takingDamage'
      }
    };
    this._const = constants;
    this._character = character;
  }

  _createClass(Battle, [{
    key: 'conflict',
    value: function conflict(character) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var selfReact = function selfReact() {
          return _this._character.battle.attack(character).then(function (enemyIsAlive) {
            return _this._react(_this._character, enemyIsAlive, selfReact);
          });
        };
        var characterReact = function characterReact() {
          return character.battle.attack(_this._character).then(function (enemyIsAlive) {
            return _this._react(character, enemyIsAlive, characterReact);
          });
        };

        Promise.all([selfReact(), characterReact()]).then(resolve);
      });
    }
  }, {
    key: 'isAlive',
    value: function isAlive() {
      var life = this._character.characteristics.getValueByName(_constants.characteristic.LIFE);
      var damageTaken = this._character.characteristics.getValueByName(_constants.characteristic.DAMAGE_TAKEN);
      return life - damageTaken > 0;
    }
  }, {
    key: 'attack',
    value: function attack(character) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var attack = _this2._character.status.get('attack');
        var weapons = _this2._character.equipment.getWeapons();
        if (!weapons.length) {
          reject(new Error('Character can\'t attack without a weapon'));
        }
        Promise.all(weapons.map(function (weapon) {
          return new Promise(function (resolve, reject) {
            weapon.setFloorDamage(attack || 0);
            weapon.getAttacks().reduce(function (iterator, attack) {
              return iterator.then(function () {
                return new Promise(function (resolve, reject) {
                  setTimeout(function () {
                    var data = { attack: attack };
                    _this2._character.events.emit(_this2._const.events.BATTLE_BEFORE_ATTACK, data);
                    character.battle.defend(data.attack).then(function () {
                      _this2._character.events.emit(_this2._const.events.BATTLE_AFTER_ATTACK, data);
                      resolve();
                    });
                  }, attack.getDelay() || 0);
                });
              });
            }, Promise.resolve([])).then(resolve);
          });
        })).then(function () {
          resolve(character.battle.isAlive());
        });
      });
    }
  }, {
    key: 'defend',
    value: function defend(attack) {
      var _this3 = this;

      return new Promise(function (resolve) {
        var data = { attack: attack };
        _this3._character.events.emit(_this3._const.events.BATTLE_BEFORE_DEFEND, data);
        _this3._takeDamage(data.attack.getDamage());
        _this3._character.events.emit(_this3._const.events.BATTLE_AFTER_DEFEND, data);
        resolve();
      });
    }
  }, {
    key: '_react',
    value: function _react(self, enemyIsAlive, payback) {
      if (!self.battle.isAlive()) return false;
      if (enemyIsAlive) return payback();
      return true;
    }
  }, {
    key: '_takeDamage',
    value: function _takeDamage(damage) {
      var defense = this._character.characteristics.getValueByName(_constants.characteristic.DEFENSE);
      damage = damage - defense < 0 ? 0 : damage - defense;
      var data = { status: { damage: damage } };
      this._character.events.emit(this._const.events.BATTLE_BEFORE_TAKING_DAMAGE, data);
      this._character.characteristics.increase(_constants.characteristic.DAMAGE_TAKEN, data.status.damage);
      this._character.events.emit(this._const.events.BATTLE_AFTER_TAKING_DAMAGE, data);
    }
  }]);

  return Battle;
}();

exports.default = Battle;
module.exports = exports['default'];